<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/light.min.css">
    <script type="application/javascript" src="./playground.js"></script>
    <script type="application/javascript" src="./mermaid.js"></script>
    <script type="application/javascript" src="./prism.js"></script>
    <link rel="stylesheet" type="text/css" href="./prism.css">
    <script>mermaid.initialize({startOnLoad:true,flowchart:{useMaxWidth:false}});</script>
    <script>
      Temporal = { ...temporal.Temporal };
      Object.assign(Intl, temporal.Intl);
    </script>
    <style>
      /* https://github.com/kognise/water.css/blob/master/src/variables-light.css */
      :root {
        --background: #efefef;
        --text-muted: #999999;
        --text-bright: #000000;
        --text-width: 900px;
        --variable: #39a33c;
      }
      .mermaid svg { height: 13em; }
      body {
        font-size: 18px;
        max-width: var(--text-width);
        padding-top: 40px;  /* extra padding for banner */
      }
      pre { border-left: 4px solid var(--variable); }
      pre code[class*="language-"] { font-size: 0.85em; }
      pre[class*="language-"] { padding: 0.5em; }
      h2 { border-bottom: 2px solid var(--text-muted); margin-top: 2em; }
      h3 {
        border-bottom: 1px solid var(--text-muted);
        color: var(--text-muted);
        font-weight: normal;
      }
      h3 em { font-weight: bold; }
      h3 strong { color: var(--text-bright); }
      :not(h2) + h3 { margin-top: 2em; }
      footer {
        border-top: 1px solid var(--background);
        color: var(--text-muted);
        font-size: 0.8em;
        margin-top: 2em;
        padding-top: 10px;
      }
      .heading-link {
        left: calc((100vw - var(--text-width)) / 2 - 1.5em);
        opacity: 0;
        position: absolute;
        transition: opacity 150ms;
      }
      .heading-link:hover { text-decoration: none; }
      .heading-link::before { content: 'Â¶'; }
      h3:hover .heading-link { opacity: 1; }
      .banner {
        /* Gradient from https://joshnh.com/weblog/how-to-make-an-alert-bar/ */
        background-color: #fce94f;
        background-image: linear-gradient(135deg,
                                          transparent,
                                          transparent 25%,
                                          rgba(0, 0, 0, .05) 25%,
                                          rgba(0, 0, 0, .05) 50%,
                                          transparent 50%,
                                          transparent 75%,
                                          rgba(0, 0, 0, .05) 75%,
                                          rgba(0, 0, 0, .05));
        background-size: 20px 20px;
        box-shadow: 0 5px 0 rgba(0, 0, 0, .1);
        left: 0;
        padding: 0.4em 0;
        position: absolute;
        text-align: center;
        top: 0;
        width: 100vw;
      }
    </style>
  </head>
  <body>
    <div class="banner">
      <strong>This polyfill is a work in progress.</strong>
      It does not represent the final API of this proposal, nor even the current consensus.
    </div>
<h1 id="duration-balancing">Duration balancing</h1>
<p>With most types in Temporal, the meaning of <code>{ disambiguation: &#39;balance&#39; }</code> is straightforward.
For example, there is no such time as 11:87, so when creating a <code>Temporal.Time</code> from 11:87 in &quot;balance&quot; disambiguation mode, this must mean 12:27.
60 minutes (one hour) is subtracted from the minute part of the time, and one hour is added to the hour part.
(As for the other disambiguation modes, &quot;constrain&quot; would clip the time to 11:59, and &quot;reject&quot; would throw an exception.)</p>
<h2 id="constructing-a-duration">Constructing a duration</h2>
<p>With <a href="./duration.html"><code>Temporal.Duration</code></a>, however, balancing is less clear-cut.
It&#39;s possible to create a duration of 100 seconds, for example: <code>Temporal.Duration.from({ seconds: 100 })</code>.
100 seconds is equal to 1 minute and 40 seconds, but unlike with a <code>Temporal.Time</code>, it&#39;s an equally valid use case to want to track the duration of something in seconds, and not balance the duration to 1 minute and 40 seconds.
So constrain mode doesn&#39;t clip the seconds value to 59, and reject mode doesn&#39;t throw in this case.
They just leave the value as it is.
Balance mode lets you opt in to the balancing behaviour:</p>
<pre><code class="language-javascript">d = Temporal.Duration.from({ seconds: 100 }, { disambiguation: &#39;balance&#39; });
d.minutes  // =&gt; 1
d.seconds  // =&gt; 40</code></pre>
<p>Balancing between the different units of durations excludes years and months, because years and months can have different lengths.
In the default ISO calendar, a year can be 365 or 366 days, and a month can be 28, 29, 30, or 31 days.
Therefore, any <code>Duration</code> object with nonzero years or months can refer to a different length of time depending on when the start date is.
No balancing is ever performed between years, months, and days, because such conversion would be ambiguous.
If you need such a conversion, you must implement it yourself, since the rules can depend on the start date and the calendar in use.</p>
<p>Negative values are never allowed as <code>Temporal.Duration</code> fields, so passing one as an argument to <code>new Temporal.Duration()</code> or as a property in the object passed to <code>Temporal.Duration.from()</code> will always throw an exception, regardless of the disambiguation mode.</p>
<p>Therefore, the only case where constrain and reject mode have any effect when creating a duration, is integer overflow.
If one of the values overflows, constrain mode will cap it to <code>Number.MAX_VALUE</code>.</p>
<h2 id="duration-arithmetic">Duration arithmetic</h2>
<p>When adding two <code>Temporal.Duration</code>s, the situation is much the same as for constructing one.
It&#39;s not possible to end up with a negative value when adding two valid durations, nor is any balancing needed, so the disambiguation mode only determines what to do in the case of integer overflow.</p>
<p>The situation is very different for subtraction.
Consider a duration of 90 minutes, from which is subtracted 30 seconds.
Subtracting the fields directly would result in 90 minutes and &minus;30 seconds, which is invalid.
Therefore, it&#39;s necessary to balance the seconds with the minutes, resulting in 89 minutes and 30 seconds.</p>
<p>By default, the fields of the resulting duration are only converted between each other if one unit is negative but a larger unit is positive, in which case the smaller is balanced with the larger to avoid having negative-valued fields.</p>
<p>That&#39;s not all the balancing that <em>could</em> be done on the resulting value.
It could further be balanced into 1 hour, 29 minutes, and 30 seconds.
However, that would likely conflict with the intention of having a duration of 90 minutes in the first place, so this should be behaviour that the Temporal user opts in to.
With subtraction, we make a distinction between &quot;necessary balancing&quot; and &quot;optional balancing&quot;.</p>
<p>In order to accommodate this, the <code>disambiguation</code> option when subtracting <code>Temporal.Duration</code>s is different from all the other arithmetic methods&#39; disambiguation options.
Necessary balancing is called <code>balanceConstrain</code> mode, because values are constrained to be non-negative through balancing.
Optional balancing is called <code>balance</code> mode.
The usual <code>constrain</code> and <code>reject</code> modes are not available.</p>
<p>The default is <code>balanceConstrain</code> mode.
The <code>balance</code> mode is only provided for convenience, since the following code snippets give the same result:</p>
<pre><code class="language-javascript">duration3 = duration1.minus(duration2, { disambiguation: &#39;balance&#39; });

tmp = duration1.minus(duration2);
// duration3 = Temporal.Duration.from(tmp, { disambiguation: &#39;balance&#39; }); - FIXME: https://github.com/tc39/proposal-temporal/issues/232
duration3 = tmp.with(tmp, { disambiguation: &#39;balance&#39; });</code></pre>
<p>Here are some more examples of what each mode does:</p>
<pre><code class="language-javascript">// Simple, no balancing possible
one = Temporal.Duration.from({ hours: 3 });
two = Temporal.Duration.from({ hours: 1 });
one.minus(two);                                 // =&gt; PT2H
one.minus(two, { disambiguation: &#39;balance&#39; });  // =&gt; PT2H

// Balancing possible but not necessary
one = Temporal.Duration.from({ minutes: 180 });
two = Temporal.Duration.from({ minutes: 60 });
one.minus(two);                                 // =&gt; PT120M
one.minus(two, { disambiguation: &#39;balance&#39; });  // =&gt; PT2H

// Some balancing necessary, more balancing possible
one = Temporal.Duration.from({ minutes: 180 });
two = Temporal.Duration.from({ seconds: 30 });
one.minus(two);                                 // =&gt; PT179M30S
one.minus(two, { disambiguation: &#39;balance&#39; });  // =&gt; PT2H59M30S

// Balancing necessary, result is positive
one = Temporal.Duration.from({ hours: 4, minutes: 15 });
two = Temporal.Duration.from({ hours: 2, minutes: 30 });
one.minus(two);                                 // =&gt; PT1H45M
one.minus(two, { disambiguation: &#39;balance&#39; });  // =&gt; PT1H45M

// Result is negative
one = Temporal.Duration.from({ hours: 2, minutes: 30 });
two = Temporal.Duration.from({ hours: 3 });
one.minus(two);                                 // throws
one.minus(two, { disambiguation: &#39;balance&#39; });  // throws

// Unbalanceable units, but also no balancing possible
one = Temporal.Duration.from({ months: 3, days: 15 });
two = Temporal.Duration.from({ days: 10 });
one.minus(two);                                 // =&gt; P3M5D
one.minus(two, { disambiguation: &#39;balance&#39; });  // =&gt; P3M5D

// Result is in theory positive in the ISO calendar, but unbalanceable units
one = Temporal.Duration.from({ months: 3, days: 15 });
two = Temporal.Duration.from({ days: 30 });
one.minus(two);                                 // throws
one.minus(two, { disambiguation: &#39;balance&#39; });  // throws</code></pre>
<h2 id="serialization">Serialization</h2>
<p>Normally, any Temporal object can be serialized to a string with its <code>toString()</code> method, and deserialized by calling <code>from()</code> on the string.
This goes for <code>Temporal.Duration</code> as well.
However, if any of the <code>milliseconds</code>, <code>microseconds</code>, or <code>nanoseconds</code> properties are greater than 999, then <code>Temporal.Duration.from(duration.toString())</code> will not yield an identical <code>Temporal.Duration</code> object.
The deserialized object will represent an equally long duration, but the sub-second fields will be balanced with the <code>seconds</code> field so that they become 999 or less.
For example, 1000 nanoseconds will become 1 microsecond.</p>
<p>This is because the ISO 8601 string format for durations, which is used for serialization for reasons of interoperability, does not allow for specifying sub-second units separately, only as a decimal fraction of seconds.
If you need to serialize a <code>Temporal.Duration</code> in a way that will preserve unbalanced sub-second fields, you will need to use a custom serialization format.</p>
    <footer>
      <p>
        This page includes a script which loads an implementation of Temporal in your browser.
        You can open a console in your browser's developer tools and try it out directly!
      </p>
      <p>View this or help contribute on <a href="https://github.com/tc39/proposal-temporal">GitHub</a>.</p>
    </footer>
    <script>
      // Add permalinks to all <h3> elements (function documentation headings)
      const h3s = document.getElementsByTagName('h3');
      for (let h3 of h3s) {
        const anchor = document.createElement('a');
        anchor.className = 'heading-link';

        // Use the **function name** as the link ID, otherwise fall back to the
        // ID generated by markdown
        let id = h3.getAttribute('id');
        const bold = h3.getElementsByTagName('strong');
        if (bold[0]) {
          id = bold[0].textContent.replace(/[^a-zA-Z]/g, '-');
          h3.setAttribute('id', id);
        }

        anchor.setAttribute('href', `#${id}`);
        h3.prepend(anchor);
      };
    </script>
  </body>
</html>
