<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/light.min.css">
    <script type="application/javascript" src="./playground.js"></script>
    <script type="application/javascript" src="./mermaid.js"></script>
    <script type="application/javascript" src="./prism.js"></script>
    <link rel="stylesheet" type="text/css" href="./prism.css">
    <script>mermaid.initialize({startOnLoad:true,flowchart:{useMaxWidth:false}});</script>
    <script>
      Temporal = { ...temporal.Temporal };
      Object.assign(Intl, temporal.Intl);
    </script>
    <style>
      /* https://github.com/kognise/water.css/blob/master/src/variables-light.css */
      :root {
        --background: #efefef;
        --text-muted: #999999;
        --text-bright: #000000;
        --text-width: 900px;
        --variable: #39a33c;
      }
      .mermaid svg { height: 13em; }
      body {
        font-size: 18px;
        max-width: var(--text-width);
        padding-top: 40px;  /* extra padding for banner */
      }
      pre { border-left: 4px solid var(--variable); }
      pre code[class*="language-"] { font-size: 0.85em; }
      pre[class*="language-"] { padding: 0.5em; }
      h2 { border-bottom: 2px solid var(--text-muted); margin-top: 2em; }
      h3 {
        border-bottom: 1px solid var(--text-muted);
        color: var(--text-muted);
        font-weight: normal;
      }
      h3 em { font-weight: bold; }
      h3 strong { color: var(--text-bright); }
      :not(h2) + h3 { margin-top: 2em; }
      footer {
        border-top: 1px solid var(--background);
        color: var(--text-muted);
        font-size: 0.8em;
        margin-top: 2em;
        padding-top: 10px;
      }
      .heading-link {
        left: calc((100vw - var(--text-width)) / 2 - 1.5em);
        opacity: 0;
        position: absolute;
        transition: opacity 150ms;
      }
      .heading-link:hover { text-decoration: none; }
      .heading-link::before { content: 'Â¶'; }
      h3:hover .heading-link { opacity: 1; }
      .banner {
        /* Gradient from https://joshnh.com/weblog/how-to-make-an-alert-bar/ */
        background-color: #fce94f;
        background-image: linear-gradient(135deg,
                                          transparent,
                                          transparent 25%,
                                          rgba(0, 0, 0, .05) 25%,
                                          rgba(0, 0, 0, .05) 50%,
                                          transparent 50%,
                                          transparent 75%,
                                          rgba(0, 0, 0, .05) 75%,
                                          rgba(0, 0, 0, .05));
        background-size: 20px 20px;
        box-shadow: 0 5px 0 rgba(0, 0, 0, .1);
        left: 0;
        padding: 0.4em 0;
        position: absolute;
        text-align: center;
        top: 0;
        width: 100vw;
      }
    </style>
  </head>
  <body>
    <div class="banner">
      <strong>This polyfill is a work in progress.</strong>
      It does not represent the final API of this proposal, nor even the current consensus.
    </div>
<h1 id="temporal-cookbook">Temporal Cookbook</h1>
<h2 id="overview">Overview</h2>
<!-- MarkdownTOC autolink="true" -->

<ul>
<li><a href="#running-the-cookbook-files">Running the cookbook files</a></li>
<li><a href="#frequently-asked-questions">Frequently Asked Questions</a><ul>
<li><a href="#current-date-and-time">Current date and time</a></li>
<li><a href="#unix-timestamp">Unix timestamp</a></li>
</ul>
</li>
<li><a href="#converting-between-temporal-types-and-legacy-date">Converting between Temporal types and legacy Date</a><ul>
<li><a href="#absolute-from-legacy-date">Absolute from legacy Date</a></li>
</ul>
</li>
<li><a href="#construction">Construction</a><ul>
<li><a href="#time-zone-object-from-name">Time zone object from name</a></li>
</ul>
</li>
<li><a href="#serialization">Serialization</a><ul>
<li><a href="#zoned-instant-from-instant-and-time-zone">Zoned instant from instant and time zone</a></li>
</ul>
</li>
<li><a href="#sorting">Sorting</a><ul>
<li><a href="#sort-datetimes">Sort DateTimes</a></li>
<li><a href="#sort-iso-datetime-strings">Sort ISO date/time strings</a></li>
</ul>
</li>
<li><a href="#time-zone-conversion">Time zone conversion</a><ul>
<li><a href="#preserving-absolute-instant">Preserving absolute instant</a></li>
<li><a href="#utc-offset-for-a-zoned-event-as-a-string">UTC offset for a zoned event, as a string</a></li>
<li><a href="#utc-offset-for-a-zoned-event-as-a-number-of-seconds">UTC offset for a zoned event, as a number of seconds</a></li>
<li><a href="#offset-between-two-time-zones-at-an-instant">Offset between two time zones at an instant</a></li>
</ul>
</li>
<li><a href="#arithmetic">Arithmetic</a><ul>
<li><a href="#unit-constrained-duration-between-now-and-a-pastfuture-zoned-event">Unit-constrained duration between now and a past/future zoned event</a></li>
<li><a href="#comparison-of-an-instant-to-business-hours">Comparison of an instant to business hours</a></li>
<li><a href="#nth-weekday-of-the-month">Nth weekday of the month</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->

<h2 id="running-the-cookbook-files">Running the cookbook files</h2>
<p>Running cookbook files:</p>
<pre><code class="language-sh">node --experimental-modules --no-warnings \
    --icu-data-dir ./polyfill/node_modules/full-icu/ \
    -r ./polyfill/index.js ./docs/cookbook/${cookbookFile}</code></pre>
<p><em>The above code allows <code>Temporal</code> to exist as a global object before the cookbook file runs.</em></p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<p>These are some of the most common tasks that people ask questions about on StackOverflow with legacy Date.
Here&#39;s how they would look using Temporal.</p>
<h3 id="current-date-and-time">Current date and time</h3>
<p>How to get the current date and time in the local time zone?</p>
<pre><code class="language-javascript">/**
 * Get the current date in JavaScript
 * This is a popular question on Stack Overflow for dates in JS
 * https://stackoverflow.com/questions/1531093/how-do-i-get-the-current-date-in-javascript
 *
 */

const dateTime = Temporal.now.dateTime(); // Gets the current date
dateTime.toString(); // returns the date in ISO 8601 date format</code></pre>
<h3 id="unix-timestamp">Unix timestamp</h3>
<p>How to get a Unix timestamp?</p>
<pre><code class="language-javascript">/**
 * Get a (Unix) timestamp in JavaScript
 * This is the No.1 voted question on Stack Overflow for dates in JS
 * https://stackoverflow.com/questions/221294/how-do-you-get-a-timestamp-in-javascript
 *
 */

const timeStamp = Temporal.now.absolute();

// Timestamp in Milliseconds
timeStamp.getEpochMilliseconds();
// Timestamp in Seconds
timeStamp.getEpochSeconds();</code></pre>
<h2 id="converting-between-temporal-types-and-legacy-date">Converting between Temporal types and legacy Date</h2>
<h3 id="absolute-from-legacy-date">Absolute from legacy Date</h3>
<p>Map a legacy ECMAScript Date instance into a Temporal.Absolute instance corresponding to the same instant in absolute time.</p>
<pre><code class="language-javascript">const legacyDate = new Date(&#39;1970-01-01T00:00:01Z&#39;);

// Convert legacy Date to Temporal.Absolute
const absolute = Temporal.Absolute.fromEpochMilliseconds(legacyDate.getTime());

assert(absolute instanceof Temporal.Absolute);</code></pre>
<h2 id="construction">Construction</h2>
<h3 id="time-zone-object-from-name">Time zone object from name</h3>
<p><code>Temporal.TimeZone.from()</code> can convert an IANA time zone name into a <code>Temporal.TimeZone</code> object.</p>
<pre><code class="language-javascript">// Construct a Temporal.TimeZone from an IANA name:
const tz = Temporal.TimeZone.from(&#39;Europe/London&#39;);

// Cast the timezone back to an IANA name, two ways:
tz.toString(); // Europe/London
tz.name; // Europe/London</code></pre>
<h2 id="serialization">Serialization</h2>
<h3 id="zoned-instant-from-instant-and-time-zone">Zoned instant from instant and time zone</h3>
<p>Use the optional parameter of <code>Temporal.Absolute.prototype.toString()</code> to map a Temporal.Absolute instance and a time zone name into a string serialization of the local time in that zone corresponding to the instant in absolute time.</p>
<p>Without the parameter, <code>Temporal.Absolute.prototype.toString()</code> gives a serialization in UTC time.
Using the parameter is useful if you need your serialized strings to be in a specific time zone.</p>
<pre><code class="language-javascript">const absoluteTime = Temporal.Absolute.from(&#39;2020-01-03T10:41:51Z&#39;);

const result = absoluteTime.toString(&#39;Europe/Paris&#39;);

assert.equal(result, &#39;2020-01-03T11:41:51+01:00[Europe/Paris]&#39;);
assert.equal(Temporal.Absolute.compare(absoluteTime, Temporal.Absolute.from(result)), 0);

// With an offset:

const result2 = absoluteTime.toString(&#39;-07:00&#39;);

assert.equal(result2, &#39;2020-01-03T03:41:51-07:00&#39;);

// With a Temporal.TimeZone object:

const timeZone = Temporal.TimeZone.from(&#39;Asia/Seoul&#39;);
const result3 = absoluteTime.toString(timeZone);

assert.equal(result3, &#39;2020-01-03T19:41:51+09:00[Asia/Seoul]&#39;);</code></pre>
<h2 id="sorting">Sorting</h2>
<p>Each Temporal type has a <code>compare()</code> static method, which can be passed to <code>Array.prototype.sort()</code> as the compare function in order to sort an array of Temporal types.</p>
<h3 id="sort-datetimes">Sort DateTimes</h3>
<p>Sort a list of <code>Temporal.DateTime</code>s, for example in order to get a conference schedule in the correct order.
Sorting other Temporal types would work exactly the same way as this.</p>
<pre><code class="language-javascript">/**
 * getSortedLocalDateTimes will sort an array of zoneless Temporal.DateTime instances by the
 * corresponding local date and time of day (e.g., for building a conference schedule).
 *
 *
 * @param {Temporal.DateTime[]} dateTimes - This is a DateTime instance
 * @param {boolean} direction - reverse
 * @returns {Temporal.DateTime[]} the array from dateTimes, sorted
 */
function getSortedLocalDateTimes(dateTimes, reverse = false) {
  let newDateTimes = Array.from(dateTimes).sort(Temporal.DateTime.compare);

  return reverse ? newDateTimes.reverse() : newDateTimes;
}

// Sorting some conferences without timezones for example vue.js Amsterdam 2020
let a = Temporal.DateTime.from({
  year: 2020,
  day: 20,
  month: 2,
  hour: 8,
  minute: 45
}); // Introduction
let b = Temporal.DateTime.from({
  year: 2020,
  day: 21,
  month: 2,
  hour: 13,
  minute: 10
}); // Lunch Break
let c = Temporal.DateTime.from({
  year: 2020,
  day: 20,
  month: 2,
  hour: 15,
  minute: 30
}); // Coffee Break
const results = getSortedLocalDateTimes([a, b, c]);
assert.equal(results[0], a);
assert.equal(results[1], c);
assert.equal(results[2], b);</code></pre>
<h3 id="sort-iso-datetime-strings">Sort ISO date/time strings</h3>
<p>Sort a list of ISO 8601 date/time strings, for example to place log entries in order.</p>
<pre><code class="language-javascript">/**
 * getSortedInstants will sort an array of strings (each of which is parseable
 * as a Temporal.Absolute and may or may not include an IANA time zone name)
 * by the corresponding absolute time (e.g., for presenting global log events
 * sequentially).
 *
 *
 * @param {string[]} parseableAbsoluteStrings - a group of ISO Strings
 * @param {boolean} reverse - ascending or descending order
 * @returns {string[]} the array from parseableAbsoluteStrings, sorted
 */
function getSortedInstants(parseableAbsoluteStrings, reverse = false) {
  const sortedAbsoluteTimes = parseableAbsoluteStrings
    .map((v) =&gt; [v, Temporal.Absolute.from(v)])
    .sort(([, abs1], [, abs2]) =&gt; Temporal.Absolute.compare(abs1, abs2))
    .map(([str]) =&gt; str);

  return reverse ? sortedAbsoluteTimes.reverse() : sortedAbsoluteTimes;
}

const a = &#39;2020-01-23T17:04:36.491865121-08:00&#39;;
const b = &#39;2020-02-10T17:04:36.491865121-08:00&#39;;
const c = &#39;2019-03-30T01:45:00+01:00[Europe/Berlin]&#39;;
const d = &#39;2019-03-16T01:45:00+00:00[Europe/London]&#39;;
const e = &#39;2019-03-25T01:45:00-06:00[America/New_York]&#39;;

const results = getSortedInstants([a, b, c, d, e]);

// results will have correct order
assert.equal(results[0], &#39;2019-03-16T01:45:00+00:00[Europe/London]&#39;);
assert.equal(results[1], &#39;2019-03-25T01:45:00-06:00[America/New_York]&#39;);
assert.equal(results[2], &#39;2019-03-30T01:45:00+01:00[Europe/Berlin]&#39;);
assert.equal(results[3], &#39;2020-01-23T17:04:36.491865121-08:00&#39;);
assert.equal(results[4], &#39;2020-02-10T17:04:36.491865121-08:00&#39;);</code></pre>
<h2 id="time-zone-conversion">Time zone conversion</h2>
<h3 id="preserving-absolute-instant">Preserving absolute instant</h3>
<p>Map a zoned date and time of day into a string serialization of the local time in a target zone at the corresponding instant in absolute time.
This could be used when converting user-input date-time values between time zones.</p>
<pre><code class="language-javascript">/**
 * Takes a local date and time in one time zone, and serializes it to a string
 * expressing the local date and time in another time zone.
 *
 * If `sourceDateTime` doesn&#39;t exist in `sourceTimeZone`, or exists twice, then
 * an error will be thrown by default.
 * Usually this is what you want. (FIXME: but is it?)
 * Use `sourceDisambiguationPolicy` to change this behaviour.
 *
 * @param {Temporal.DateTime} sourceDateTime - The local date and time
 * @param {Temporal.TimeZone} sourceTimeZone - The time zone for
 *  `sourceDateTime`
 * @param {Temporal.TimeZone} targetTimeZone - The time zone for the
 *  return value
 * @param {string} [sourceDisambiguationPolicy=reject] - what to do when
 *  `sourceDateTime` is ambiguous
 * @returns {string} String indicating the time with time zone designation
 */
function getParseableZonedStringWithLocalTimeInOtherZone(
  sourceDateTime,
  sourceTimeZone,
  targetTimeZone,
  sourceDisambiguationPolicy = &#39;reject&#39;
) {
  let instant = sourceDateTime.inTimeZone(sourceTimeZone, { disambiguation: sourceDisambiguationPolicy });
  return instant.toString(targetTimeZone);
}

const result = getParseableZonedStringWithLocalTimeInOtherZone(
  Temporal.DateTime.from(&#39;2020-01-09T00:00&#39;),
  Temporal.TimeZone.from(&#39;America/Chicago&#39;),
  Temporal.TimeZone.from(&#39;America/Los_Angeles&#39;)
);
// On this date, when it&#39;s midnight in Chicago, it&#39;s 10 PM the previous night in LA
assert.equal(result, &#39;2020-01-08T22:00-08:00[America/Los_Angeles]&#39;);</code></pre>
<h3 id="utc-offset-for-a-zoned-event-as-a-string">UTC offset for a zoned event, as a string</h3>
<p>Use <code>Temporal.TimeZone.getOffsetFor()</code> to map a <code>Temporal.Absolute</code> instance and a time zone into the UTC offset at that instant in that time zone, as a string.</p>
<pre><code class="language-javascript">const instant = Temporal.Absolute.from(&#39;2020-01-09T00:00Z&#39;);
const nyc = Temporal.TimeZone.from(&#39;America/New_York&#39;);

nyc.getOffsetFor(instant); // =&gt; -05:00</code></pre>
<h3 id="utc-offset-for-a-zoned-event-as-a-number-of-seconds">UTC offset for a zoned event, as a number of seconds</h3>
<p>It&#39;s a bit more complicated to do the above mapping as a number of seconds instead of a string.</p>
<pre><code class="language-javascript">/**
 * Returns the number of seconds in the UTC offset of a time zone, at a
 * particular moment in time.
 *
 * @param {Temporal.Absolute} instant - A moment in time
 * @param {Temporal.TimeZone} timeZone - A time zone to examine
 * @returns {number} The number of seconds in the time zone&#39;s UTC offset
 */
function getUtcOffsetSecondsAtInstant(instant, timeZone) {
  const utcWallTime = instant.inTimeZone(&#39;UTC&#39;);
  const localWallTime = instant.inTimeZone(timeZone);
  const difference = utcWallTime.difference(localWallTime, { largestUnit: &#39;seconds&#39; });
  const sign = Temporal.DateTime.compare(localWallTime, utcWallTime) &lt; 0 ? -1 : 1;
  return (
    sign *
    (difference.seconds +
      difference.milliseconds * 1e-3 +
      difference.microseconds * 1e-6 +
      difference.nanoseconds * 1e-9)
  );
}

const instant = Temporal.Absolute.from(&#39;2020-01-09T00:00Z&#39;);
const nyc = Temporal.TimeZone.from(&#39;America/New_York&#39;);

assert.equal(getUtcOffsetSecondsAtInstant(instant, nyc), -18000);</code></pre>
<h3 id="offset-between-two-time-zones-at-an-instant">Offset between two time zones at an instant</h3>
<p>With a small variation on the previous recipe we can map a <code>Temporal.Absolute</code> instance and two time zones into the signed difference of UTC offsets between those time zones at that instant, as a number of seconds.</p>
<pre><code class="language-javascript">/**
 * Returns the number of seconds&#39; difference between the UTC offsets of two time
 * zones, at a particular moment in time.
 *
 * @param {Temporal.Absolute} instant - A moment in time
 * @param {Temporal.TimeZone} sourceTimeZone - A time zone to examine
 * @param {Temporal.TimeZone} targetTimeZone - A second time zone to examine
 * @returns {number} The number of seconds difference between the time zones&#39;
 *   UTC offsets
 */
function getUtcOffsetDifferenceSecondsAtInstant(instant, sourceTimeZone, targetTimeZone) {
  const sourceWallTime = instant.inTimeZone(sourceTimeZone);
  const targetWallTime = instant.inTimeZone(targetTimeZone);
  const difference = sourceWallTime.difference(targetWallTime, { largestUnit: &#39;seconds&#39; });
  const sign = Temporal.DateTime.compare(targetWallTime, sourceWallTime) &lt; 0 ? -1 : 1;
  return (
    sign *
    (difference.seconds +
      difference.milliseconds * 1e-3 +
      difference.microseconds * 1e-6 +
      difference.nanoseconds * 1e-9)
  );
}

const instant = Temporal.Absolute.from(&#39;2020-01-09T00:00Z&#39;);
const nyc = Temporal.TimeZone.from(&#39;America/New_York&#39;);
const chicago = Temporal.TimeZone.from(&#39;America/Chicago&#39;);

// At this instant, Chicago is 3600 seconds earlier than New York
assert.equal(getUtcOffsetDifferenceSecondsAtInstant(instant, nyc, chicago), -3600);</code></pre>
<h2 id="arithmetic">Arithmetic</h2>
<h3 id="unit-constrained-duration-between-now-and-a-pastfuture-zoned-event">Unit-constrained duration between now and a past/future zoned event</h3>
<p>Map two Temporal.Absolute instances into an ascending/descending order indicator and a Temporal.Duration instance representing the duration between the two instants without using units coarser than specified (e.g., for presenting a meaningful countdown with vs. without using months or days).</p>
<pre><code class="language-javascript">/**
 * @typedef {Object} ElapsedDuration
 * @property {string} return.sign - &quot;+&quot; or &quot;-&quot;
 * @property {Temporal.Duration} return.duration - Elapsed duration
 */
/**
 * Compute the difference between two instants, suitable for use in a countdown,
 * for example.
 *
 * @param {Temporal.Absolute} then - Instant since when to measure the duration
 * @param {Temporal.Absolute} now - Instant until when to measure the duration
 * @param {string} [largestUnit=days] - Largest time unit to have in the result
 * @returns {ElapsedDuration} Time between `then` and `now`
 */
function getElapsedDurationSinceInstant(then, now, largestUnit = &#39;days&#39;) {
  const sign = Temporal.Absolute.compare(now, then) &lt; 0 ? &#39;-&#39; : &#39;+&#39;;
  const duration = now.difference(then, { largestUnit });
  return { sign, duration };
}

const result = getElapsedDurationSinceInstant(
  Temporal.Absolute.from(&#39;2020-01-09T00:00Z&#39;),
  Temporal.Absolute.from(&#39;2020-01-09T04:00Z&#39;)
);
assert.equal(`${result.sign}${result.duration}`, &#39;+PT4H&#39;);

const result2 = getElapsedDurationSinceInstant(
  Temporal.Absolute.from(&#39;2020-01-09T04:00Z&#39;),
  Temporal.Absolute.from(&#39;2020-01-09T00:00Z&#39;),
  &#39;minutes&#39;
);
assert.equal(`${result2.sign}${result2.duration}`, &#39;-PT240M&#39;);

// Example of using it in a countdown:

const { sign, duration } = getElapsedDurationSinceInstant(
  Temporal.Absolute.from(&#39;2020-04-01T13:00-07:00[America/Los_Angeles]&#39;),
  Temporal.now.absolute()
);
`It&#39;s ${duration.toLocaleString()} ${sign &lt; 0 ? &#39;until&#39; : &#39;since&#39;} the TC39 Temporal presentation`;</code></pre>
<h3 id="comparison-of-an-instant-to-business-hours">Comparison of an instant to business hours</h3>
<p>This example takes a roster of opening and closing times for a business, and maps a localized date and time of day into a time-sensitive state indicator (&quot;opening soon&quot; vs. &quot;open&quot; vs. &quot;closing soon&quot; vs. &quot;closed&quot;).</p>
<pre><code class="language-javascript">/**
 * Compare the given time to the business hours of a business located in a
 * particular time zone, and return a string indicating whether the business is
 * open, closed, opening soon, or closing soon. The length of &quot;soon&quot; can be
 * controlled using the `soonWindow` parameter.
 *
 * @param {Temporal.Absolute} now - Time at which to consider whether the
 *  business is open
 * @param {Temporal.TimeZone} timeZone - Time zone in which the business is
 *  located
 * @param {(Object|null)[]} businessHours - Array of length 7 indicating
 *  business hours during the week
 * @param {Temporal.Time} businessHours[].open - Time at which the business
 *  opens
 * @param {Temporal.Time} businessHours[].close - Time at which the business
 *  closes
 * @param {Temporal.Duration} soonWindow - Length of time before the opening or
 *  closing time during which the business should be considered &quot;opening soon&quot;
 *  or &quot;closing soon&quot;
 * @returns {string} &quot;open&quot;, &quot;closed&quot;, &quot;opening soon&quot;, or &quot;closing soon&quot;
 */
function getBusinessOpenStateText(now, timeZone, businessHours, soonWindow) {
  function inRange(dateTime, start, end) {
    return Temporal.DateTime.compare(dateTime, start) &gt;= 0 &amp;&amp; Temporal.DateTime.compare(dateTime, end) &lt; 0;
  }

  const dateTime = now.inTimeZone(timeZone);
  const weekday = dateTime.dayOfWeek % 7; // convert to 0-based, for array indexing

  // Because of times wrapping around at midnight, we may need to consider
  // yesterday&#39;s and tomorrow&#39;s hours as well
  const today = dateTime.getDate();
  const yesterday = today.minus({ days: 1 });
  const tomorrow = today.plus({ days: 1 });

  // Push any of the businessHours that overlap today&#39;s date into an array,
  // that we will subsequently check. Convert the businessHours Times into
  // DateTimes so that they no longer wrap around.
  const businessHoursOverlappingToday = [];
  const yesterdayHours = businessHours[(weekday + 6) % 7];
  if (yesterdayHours) {
    const { open, close } = yesterdayHours;
    if (Temporal.Time.compare(close, open) &lt; 0) {
      businessHoursOverlappingToday.push({
        open: yesterday.withTime(open),
        close: today.withTime(close)
      });
    }
  }
  const todayHours = businessHours[weekday];
  if (todayHours) {
    const { open, close } = todayHours;
    businessHoursOverlappingToday.push({
      open: today.withTime(open),
      close: (Temporal.Time.compare(close, open) &gt;= 0 ? today : tomorrow).withTime(close)
    });
  }

  // Check if any of the candidate business hours include the given time
  const soon = dateTime.plus(soonWindow);
  let openNow = false;
  let openSoon = false;
  for (const { open, close } of businessHoursOverlappingToday) {
    openNow = openNow || inRange(dateTime, open, close);
    openSoon = openSoon || inRange(soon, open, close);
  }

  if (openNow) {
    if (!openSoon) return &#39;closing soon&#39;;
    return &#39;open&#39;;
  }
  if (openSoon) return &#39;opening soon&#39;;
  return &#39;closed&#39;;
}

// For example, a restaurant or bar might have opening hours that go past
// midnight; make sure this is handled correctly
const businessHours = [
  /* Sun */ { open: Temporal.Time.from(&#39;13:00&#39;), close: Temporal.Time.from(&#39;20:30&#39;) },
  /* Mon */ null, // closed Mondays
  /* Tue */ { open: Temporal.Time.from(&#39;11:00&#39;), close: Temporal.Time.from(&#39;20:30&#39;) },
  /* Wed */ { open: Temporal.Time.from(&#39;11:00&#39;), close: Temporal.Time.from(&#39;20:30&#39;) },
  /* Thu */ { open: Temporal.Time.from(&#39;11:00&#39;), close: Temporal.Time.from(&#39;22:00&#39;) },
  /* Fri */ { open: Temporal.Time.from(&#39;11:00&#39;), close: Temporal.Time.from(&#39;00:00&#39;) },
  /* Sat */ { open: Temporal.Time.from(&#39;11:00&#39;), close: Temporal.Time.from(&#39;02:00&#39;) }
];

const now = Temporal.Absolute.from(&#39;2019-04-07T00:00+01:00[Europe/Berlin]&#39;);
const tz = Temporal.TimeZone.from(&#39;Europe/Berlin&#39;);
const saturdayNightState = getBusinessOpenStateText(now, tz, businessHours, Temporal.Duration.from({ minutes: 30 }));
assert.equal(saturdayNightState, &#39;open&#39;);</code></pre>
<h3 id="nth-weekday-of-the-month">Nth weekday of the month</h3>
<p>Example of getting a <code>Temporal.Date</code> representing the first Tuesday of the given <code>Temporal.YearMonth</code>, adaptable to other weekdays.</p>
<pre><code class="language-javascript">/**
 * Gets the first Tuesday of the month and returns its date
 *
 * @param {Temporal.YearMonth} queriedMonth - YearMonth instance to query
 * @returns {Temporal.Date} Temporal.Date Instance which gives first tuesday
 */
function getFirstTuesday(queriedMonth) {
  // We first need to convert to a date
  const firstOfMonth = queriedMonth.withDay(1);

  // We have Monday = 1, Sunday = 7, and we want to add a positive number
  // smaller than 7 to get to the first Tuesday.
  // If we&#39;re already on a Tuesday (2) then we want to add 0.
  // So for the first of the month being a Monday through Sunday the additions are:
  //    1, 0, 6, 5, 4, 3, 2 which is given by that formula.
  // This lookup table makes this example easier to read, but you can also
  // calculate the answer: (7 + desiredWeekday - firstOfMonth.dayOfWeek) % 7
  return firstOfMonth.plus({ days: [1, 0, 6, 5, 4, 3, 2][firstOfMonth.dayOfWeek - 1] });
}

const myMonth = Temporal.YearMonth.from(&#39;2020-02&#39;);
const firstTuesdayOfMonth = getFirstTuesday(myMonth);
assert.equal(firstTuesdayOfMonth.toString(), &#39;2020-02-04&#39;);
assert.equal(firstTuesdayOfMonth.dayOfWeek, 2);</code></pre>
    <footer>
      <p>
        This page includes a script which loads an implementation of Temporal in your browser.
        You can open a console in your browser's developer tools and try it out directly!
      </p>
      <p>View this or help contribute on <a href="https://github.com/tc39/proposal-temporal">GitHub</a>.</p>
    </footer>
    <script>
      // Add permalinks to all <h3> elements (function documentation headings)
      const h3s = document.getElementsByTagName('h3');
      for (let h3 of h3s) {
        const anchor = document.createElement('a');
        anchor.className = 'heading-link';

        // Use the **function name** as the link ID, otherwise fall back to the
        // ID generated by markdown
        let id = h3.getAttribute('id');
        const bold = h3.getElementsByTagName('strong');
        if (bold[0]) {
          id = bold[0].textContent.replace(/[^a-zA-Z]/g, '-');
          h3.setAttribute('id', id);
        }

        anchor.setAttribute('href', `#${id}`);
        h3.prepend(anchor);
      };
    </script>
  </body>
</html>
